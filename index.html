<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="utf-8" />
		<meta name="description" content="" />
		<link rel="icon" href="https://kdheepak.com/PowerSystemsTypes/favicon.png" />
		<meta name="viewport" content="width=device-width, initial-scale=1" />
		<meta http-equiv="content-security-policy" content="">
	<link rel="stylesheet" href="https://kdheepak.com/PowerSystemsTypes/_app/assets/vendor-25d37b17.css">
	<link rel="stylesheet" href="https://kdheepak.com/PowerSystemsTypes/_app/assets/pages/__layout.svelte-688983bf.css">
	<link rel="modulepreload" href="https://kdheepak.com/PowerSystemsTypes/_app/start-39914118.js">
	<link rel="modulepreload" href="https://kdheepak.com/PowerSystemsTypes/_app/chunks/vendor-47625316.js">
	<link rel="modulepreload" href="https://kdheepak.com/PowerSystemsTypes/_app/chunks/paths-cb1adeb5.js">
	<link rel="modulepreload" href="https://kdheepak.com/PowerSystemsTypes/_app/pages/__layout.svelte-b9a76f5f.js">
	<link rel="modulepreload" href="https://kdheepak.com/PowerSystemsTypes/_app/pages/index.svelte-cfd42d89.js">
	</head>
	<body>
		<div>


<div class="h-screen w-screen grid svelte-qtn8ri"><nav class="relative w-full flex flex-wrap items-center justify-between py-3 bg-gray-900 text-gray-200 shadow-lg navbar navbar-expand-lg navbar-light"><div class="container-fluid w-full flex flex-wrap items-center justify-between px-6"><div class="collapse navbar-collapse flex-grow items-center" id="navbarSupportedContent1"><a class="text-xl text-white pr-2 font-semibold" href="/PowerSystemsTypes/">PowerSystems.jl Types</a>
      
      <ul class="navbar-nav flex flex-col pl-0 list-style-none mr-auto"><li class="nav-item p-2"><a class="nav-link text-white" href="/PowerSystemsTypes/">Dashboard</a></li></ul>
      </div>
    

    
    <div class="flex items-center relative"><a href="https://github.com/NREL-SIIP"><svg version="1.1" class="fa-icon  svelte-roizm6" width="15.5" height="16" role="presentation" viewBox="0 0 496 512">
    <path id="path-0" d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z"></path>
      
      
  </svg></a></div>
    </div></nav>
  <main><div id="tooltip" class="grid mx-32 h-1/6 justify-start align-bottom"></div>

<div class="grid mx-32 h-5/6">



</div></main>
</div>


		<script type="module" data-hydrate="l1dc7s">
		import { start } from "https://kdheepak.com/PowerSystemsTypes/_app/start-39914118.js";
		start({
			target: document.querySelector('[data-hydrate="l1dc7s"]').parentNode,
			paths: {"base":"/PowerSystemsTypes","assets":"https://kdheepak.com/PowerSystemsTypes"},
			session: {},
			route: true,
			spa: false,
			trailing_slash: "never",
			hydrate: {
				status: 200,
				error: null,
				nodes: [
					import("https://kdheepak.com/PowerSystemsTypes/_app/pages/__layout.svelte-b9a76f5f.js"),
						import("https://kdheepak.com/PowerSystemsTypes/_app/pages/index.svelte-cfd42d89.js")
				],
				params: {}
			}
		});
	</script><script type="application/json" data-type="svelte-props">{"data":{"name":"Component","documentation":"Supertype for all PowerSystems components. All subtypes must include a InfrastructureSystemsInternal member. Subtypes should call InfrastructureSystemsInternal() by default, but also must provide a constructor that allows existing values to be deserialized.\n","children":[{"name":"Device","documentation":"Supertype for \"devices\" (bus, line, etc.) \n","children":[{"name":"Branch","documentation":"No documentation found.\n\n# Summary\n\n```\nabstract type Branch\n```\n\n# Subtypes\n\n```\nACBranch\nDCBranch\n```\n\n# Supertype Hierarchy\n\n```\nBranch \u003C: Device \u003C: Component \u003C: InfrastructureSystems.InfrastructureSystemsComponent \u003C: InfrastructureSystems.InfrastructureSystemsType \u003C: Any\n```\n","children":[{"name":"ACBranch","documentation":"No documentation found.\n\n# Summary\n\n```\nabstract type ACBranch\n```\n\n# Subtypes\n\n```\nDynamicBranch\nLine\nMonitoredLine\nPhaseShiftingTransformer\nTapTransformer\nTransformer2W\n```\n\n# Supertype Hierarchy\n\n```\nACBranch \u003C: Branch \u003C: Device \u003C: Component \u003C: InfrastructureSystems.InfrastructureSystemsComponent \u003C: InfrastructureSystems.InfrastructureSystemsType \u003C: Any\n```\n","children":[{"name":"DynamicBranch","fields":["branch","n_states","states","internal"],"documentation":"Extends the branch type to add the information required for dynamic modeling of branches. Includes the fields for the states and the number of states\n\n# Arguments\n\n  * `branch::ACBranch`\n"},{"name":"Line","fields":["name","available","active_power_flow","reactive_power_flow","arc","r","x","b","rate","angle_limits","services","ext","time_series_container","internal"],"documentation":"```\nmutable struct Line \u003C: ACBranch\n    name::String\n    available::Bool\n    active_power_flow::Float64\n    reactive_power_flow::Float64\n    arc::Arc\n    r::Float64\n    x::Float64\n    b::NamedTuple{(:from, :to), Tuple{Float64, Float64}}\n    rate::Float64\n    angle_limits::NamedTuple{(:min, :max), Tuple{Float64, Float64}}\n    services::Vector{Service}\n    ext::Dict{String, Any}\n    time_series_container::InfrastructureSystems.TimeSeriesContainer\n    internal::InfrastructureSystemsInternal\nend\n```\n\n# Arguments\n\n  * `name::String`\n  * `available::Bool`\n  * `active_power_flow::Float64`\n  * `reactive_power_flow::Float64`\n  * `arc::Arc`\n  * `r::Float64`: System per-unit value, validation range: `(0, 4)`, action if invalid: `warn`\n  * `x::Float64`: System per-unit value, validation range: `(0, 4)`, action if invalid: `warn`\n  * `b::NamedTuple{(:from, :to), Tuple{Float64, Float64}}`: System per-unit value, validation range: `(0, 100)`, action if invalid: `warn`\n  * `rate::Float64`\n  * `angle_limits::NamedTuple{(:min, :max), Tuple{Float64, Float64}}`, validation range: `(-1.571, 1.571)`, action if invalid: `error`\n  * `services::Vector{Service}`: Services that this device contributes to\n  * `ext::Dict{String, Any}`\n  * `time_series_container::InfrastructureSystems.TimeSeriesContainer`: internal time_series storage\n  * `internal::InfrastructureSystemsInternal`: power system internal reference, do not modify\n\n```julia\nLine(name, available::Bool, active_power_flow::Float64, reactive_power_flow::Float64, arc::Arc, r, x, b, rate, angle_limits::Float64) -\u003E Line\n\n```\n\nAccepts angle_limits as a Float64.\n"},{"name":"MonitoredLine","fields":["name","available","active_power_flow","reactive_power_flow","arc","r","x","b","flow_limits","rate","angle_limits","services","ext","time_series_container","internal"],"documentation":"```\nmutable struct MonitoredLine \u003C: ACBranch\n    name::String\n    available::Bool\n    active_power_flow::Float64\n    reactive_power_flow::Float64\n    arc::Arc\n    r::Float64\n    x::Float64\n    b::NamedTuple{(:from, :to), Tuple{Float64, Float64}}\n    flow_limits::NamedTuple{(:from_to, :to_from), Tuple{Float64, Float64}}\n    rate::Float64\n    angle_limits::NamedTuple{(:min, :max), Tuple{Float64, Float64}}\n    services::Vector{Service}\n    ext::Dict{String, Any}\n    time_series_container::InfrastructureSystems.TimeSeriesContainer\n    internal::InfrastructureSystemsInternal\nend\n```\n\n# Arguments\n\n  * `name::String`\n  * `available::Bool`\n  * `active_power_flow::Float64`\n  * `reactive_power_flow::Float64`\n  * `arc::Arc`\n  * `r::Float64`: System per-unit value, validation range: `(0, 4)`, action if invalid: `warn`\n  * `x::Float64`: System per-unit value, validation range: `(0, 4)`, action if invalid: `warn`\n  * `b::NamedTuple{(:from, :to), Tuple{Float64, Float64}}`: System per-unit value, validation range: `(0, 2)`, action if invalid: `warn`\n  * `flow_limits::NamedTuple{(:from_to, :to_from), Tuple{Float64, Float64}}`: TODO: throw warning above max SIL\n  * `rate::Float64`: TODO: compare to SIL (warn) (theoretical limit)\n  * `angle_limits::NamedTuple{(:min, :max), Tuple{Float64, Float64}}`, validation range: `(-1.571, 1.571)`, action if invalid: `error`\n  * `services::Vector{Service}`: Services that this device contributes to\n  * `ext::Dict{String, Any}`\n  * `time_series_container::InfrastructureSystems.TimeSeriesContainer`: internal time_series storage\n  * `internal::InfrastructureSystemsInternal`: power system internal reference, do not modify\n"},{"name":"PhaseShiftingTransformer","fields":["name","available","active_power_flow","reactive_power_flow","arc","r","x","primary_shunt","tap","Î±","rate","services","ext","time_series_container","internal"],"documentation":"```\nmutable struct PhaseShiftingTransformer \u003C: ACBranch\n    name::String\n    available::Bool\n    active_power_flow::Float64\n    reactive_power_flow::Float64\n    arc::Arc\n    r::Float64\n    x::Float64\n    primary_shunt::Float64\n    tap::Float64\n    Î±::Float64\n    rate::Union{Nothing, Float64}\n    services::Vector{Service}\n    ext::Dict{String, Any}\n    time_series_container::InfrastructureSystems.TimeSeriesContainer\n    internal::InfrastructureSystemsInternal\nend\n```\n\n# Arguments\n\n  * `name::String`\n  * `available::Bool`\n  * `active_power_flow::Float64`\n  * `reactive_power_flow::Float64`\n  * `arc::Arc`\n  * `r::Float64`: System per-unit value, validation range: `(0, 4)`, action if invalid: `warn`\n  * `x::Float64`: System per-unit value, validation range: `(-2, 4)`, action if invalid: `warn`\n  * `primary_shunt::Float64`, validation range: `(0, 2)`, action if invalid: `warn`\n  * `tap::Float64`, validation range: `(0, 2)`, action if invalid: `error`\n  * `Î±::Float64`, validation range: `(-1.571, 1.571)`, action if invalid: `warn`\n  * `rate::Union{Nothing, Float64}`, validation range: `(0, nothing)`, action if invalid: `error`\n  * `services::Vector{Service}`: Services that this device contributes to\n  * `ext::Dict{String, Any}`\n  * `time_series_container::InfrastructureSystems.TimeSeriesContainer`: internal time_series storage\n  * `internal::InfrastructureSystemsInternal`: power system internal reference, do not modify\n"},{"name":"TapTransformer","fields":["name","available","active_power_flow","reactive_power_flow","arc","r","x","primary_shunt","tap","rate","services","ext","time_series_container","internal"],"documentation":"```\nmutable struct TapTransformer \u003C: ACBranch\n    name::String\n    available::Bool\n    active_power_flow::Float64\n    reactive_power_flow::Float64\n    arc::Arc\n    r::Float64\n    x::Float64\n    primary_shunt::Float64\n    tap::Float64\n    rate::Union{Nothing, Float64}\n    services::Vector{Service}\n    ext::Dict{String, Any}\n    time_series_container::InfrastructureSystems.TimeSeriesContainer\n    internal::InfrastructureSystemsInternal\nend\n```\n\n# Arguments\n\n  * `name::String`\n  * `available::Bool`\n  * `active_power_flow::Float64`\n  * `reactive_power_flow::Float64`\n  * `arc::Arc`\n  * `r::Float64`: System per-unit value, validation range: `(-2, 2)`, action if invalid: `warn`\n  * `x::Float64`: System per-unit value, validation range: `(-2, 4)`, action if invalid: `warn`\n  * `primary_shunt::Float64`: System per-unit value, validation range: `(0, 2)`, action if invalid: `warn`\n  * `tap::Float64`, validation range: `(0, 2)`, action if invalid: `error`\n  * `rate::Union{Nothing, Float64}`, validation range: `(0, nothing)`, action if invalid: `error`\n  * `services::Vector{Service}`: Services that this device contributes to\n  * `ext::Dict{String, Any}`\n  * `time_series_container::InfrastructureSystems.TimeSeriesContainer`: internal time_series storage\n  * `internal::InfrastructureSystemsInternal`: power system internal reference, do not modify\n"},{"name":"Transformer2W","fields":["name","available","active_power_flow","reactive_power_flow","arc","r","x","primary_shunt","rate","services","ext","time_series_container","internal"],"documentation":"```\nmutable struct Transformer2W \u003C: ACBranch\n    name::String\n    available::Bool\n    active_power_flow::Float64\n    reactive_power_flow::Float64\n    arc::Arc\n    r::Float64\n    x::Float64\n    primary_shunt::Float64\n    rate::Union{Nothing, Float64}\n    services::Vector{Service}\n    ext::Dict{String, Any}\n    time_series_container::InfrastructureSystems.TimeSeriesContainer\n    internal::InfrastructureSystemsInternal\nend\n```\n\nThe 2-W transformer model uses an equivalent circuit assuming the impedance is on the High Voltage Side of the transformer. The model allocates the iron losses and magnetizing susceptance to the primary side.\n\n# Arguments\n\n  * `name::String`\n  * `available::Bool`\n  * `active_power_flow::Float64`\n  * `reactive_power_flow::Float64`\n  * `arc::Arc`\n  * `r::Float64`: System per-unit value, validation range: `(-2, 4)`, action if invalid: `warn`\n  * `x::Float64`: System per-unit value, validation range: `(-2, 4)`, action if invalid: `warn`\n  * `primary_shunt::Float64`: System per-unit value, validation range: `(0, 2)`, action if invalid: `warn`\n  * `rate::Union{Nothing, Float64}`, validation range: `(0, nothing)`, action if invalid: `error`\n  * `services::Vector{Service}`: Services that this device contributes to\n  * `ext::Dict{String, Any}`\n  * `time_series_container::InfrastructureSystems.TimeSeriesContainer`: internal time_series storage\n  * `internal::InfrastructureSystemsInternal`: power system internal reference, do not modify\n"}]},{"name":"DCBranch","documentation":"No documentation found.\n\n# Summary\n\n```\nabstract type DCBranch\n```\n\n# Subtypes\n\n```\nHVDCLine\nVSCDCLine\n```\n\n# Supertype Hierarchy\n\n```\nDCBranch \u003C: Branch \u003C: Device \u003C: Component \u003C: InfrastructureSystems.InfrastructureSystemsComponent \u003C: InfrastructureSystems.InfrastructureSystemsType \u003C: Any\n```\n","children":[{"name":"HVDCLine","fields":["name","available","active_power_flow","arc","active_power_limits_from","active_power_limits_to","reactive_power_limits_from","reactive_power_limits_to","loss","services","ext","time_series_container","internal"],"documentation":"```\nmutable struct HVDCLine \u003C: DCBranch\n    name::String\n    available::Bool\n    active_power_flow::Float64\n    arc::Arc\n    active_power_limits_from::NamedTuple{(:min, :max), Tuple{Float64, Float64}}\n    active_power_limits_to::NamedTuple{(:min, :max), Tuple{Float64, Float64}}\n    reactive_power_limits_from::NamedTuple{(:min, :max), Tuple{Float64, Float64}}\n    reactive_power_limits_to::NamedTuple{(:min, :max), Tuple{Float64, Float64}}\n    loss::NamedTuple{(:l0, :l1), Tuple{Float64, Float64}}\n    services::Vector{Service}\n    ext::Dict{String, Any}\n    time_series_container::InfrastructureSystems.TimeSeriesContainer\n    internal::InfrastructureSystemsInternal\nend\n```\n\na High voltage DC line.\n\n# Arguments\n\n  * `name::String`\n  * `available::Bool`\n  * `active_power_flow::Float64`\n  * `arc::Arc`\n  * `active_power_limits_from::NamedTuple{(:min, :max), Tuple{Float64, Float64}}`\n  * `active_power_limits_to::NamedTuple{(:min, :max), Tuple{Float64, Float64}}`\n  * `reactive_power_limits_from::NamedTuple{(:min, :max), Tuple{Float64, Float64}}`\n  * `reactive_power_limits_to::NamedTuple{(:min, :max), Tuple{Float64, Float64}}`\n  * `loss::NamedTuple{(:l0, :l1), Tuple{Float64, Float64}}`\n  * `services::Vector{Service}`: Services that this device contributes to\n  * `ext::Dict{String, Any}`\n  * `time_series_container::InfrastructureSystems.TimeSeriesContainer`: internal time_series storage\n  * `internal::InfrastructureSystemsInternal`: power system internal reference, do not modify\n"},{"name":"VSCDCLine","fields":["name","available","active_power_flow","arc","rectifier_tap_limits","rectifier_xrc","rectifier_firing_angle","inverter_tap_limits","inverter_xrc","inverter_firing_angle","services","ext","time_series_container","internal"],"documentation":"```\nmutable struct VSCDCLine \u003C: DCBranch\n    name::String\n    available::Bool\n    active_power_flow::Float64\n    arc::Arc\n    rectifier_tap_limits::NamedTuple{(:min, :max), Tuple{Float64, Float64}}\n    rectifier_xrc::Float64\n    rectifier_firing_angle::NamedTuple{(:min, :max), Tuple{Float64, Float64}}\n    inverter_tap_limits::NamedTuple{(:min, :max), Tuple{Float64, Float64}}\n    inverter_xrc::Float64\n    inverter_firing_angle::NamedTuple{(:min, :max), Tuple{Float64, Float64}}\n    services::Vector{Service}\n    ext::Dict{String, Any}\n    time_series_container::InfrastructureSystems.TimeSeriesContainer\n    internal::InfrastructureSystemsInternal\nend\n```\n\nAs implemented in Milano's Book, Page 397.\n\n# Arguments\n\n  * `name::String`\n  * `available::Bool`\n  * `active_power_flow::Float64`\n  * `arc::Arc`\n  * `rectifier_tap_limits::NamedTuple{(:min, :max), Tuple{Float64, Float64}}`\n  * `rectifier_xrc::Float64`\n  * `rectifier_firing_angle::NamedTuple{(:min, :max), Tuple{Float64, Float64}}`\n  * `inverter_tap_limits::NamedTuple{(:min, :max), Tuple{Float64, Float64}}`\n  * `inverter_xrc::Float64`\n  * `inverter_firing_angle::NamedTuple{(:min, :max), Tuple{Float64, Float64}}`\n  * `services::Vector{Service}`: Services that this device contributes to\n  * `ext::Dict{String, Any}`\n  * `time_series_container::InfrastructureSystems.TimeSeriesContainer`: internal time_series storage\n  * `internal::InfrastructureSystemsInternal`: power system internal reference, do not modify\n"}]}]},{"name":"DynamicInjection","documentation":"Abstract type for all dynamic injection types\n","children":[{"name":"DynamicGenerator","fields":["name","Ï_ref","machine","shaft","avr","prime_mover","pss","base_power","n_states","states","ext","internal"],"documentation":"```\nmutable struct DynamicGenerator{\n    M \u003C: Machine,\n    S \u003C: Shaft,\n    A \u003C: AVR,\n    TG \u003C: TurbineGov,\n    P \u003C: PSS,\n} \u003C: DynamicInjection\n    name::String\n    Ï_ref::Float64\n    machine::M\n    shaft::S\n    avr::A\n    prime_mover::TG\n    pss::P\n    base_power::Float64\n    n_states::Int\n    states::Vector{Symbol}\n    ext::Dict{String, Any}\n    internal::InfrastructureSystemsInternal\nend\n```\n\nA dynamic generator is composed by 5 components, namely a Machine, a Shaft, an Automatic Voltage Regulator (AVR), a Prime Mover (o Turbine Governor) and Power System Stabilizer (PSS). It requires a Static Injection device that is attached to it.\n\n# Arguments\n\n  * `name::String`: Name of generator.\n  * `Ï_ref::Float64`: Frequency reference set-point in pu.\n  * `machine \u003C: Machine`: Machine model for modeling the electro-magnetic phenomena.\n  * `shaft \u003C: Shaft`: Shaft model for modeling the electro-mechanical phenomena.\n  * `avr \u003C: AVR`: AVR model of the excitacion system.\n  * `prime_mover \u003C: TurbineGov`: Prime Mover and Turbine Governor model for mechanical power.\n  * `pss \u003C: PSS`: Power System Stabilizer model.\n  * `base_power::Float64`: Base power\n  * `n_states::Int`: Number of states (will depend on the components).\n  * `states::Vector{Symbol}`: Vector of states (will depend on the components).\n  * `ext::Dict{String, Any}`\n  * `internal::InfrastructureSystemsInternal`: power system internal reference, do not modify\n"},{"name":"DynamicInverter","fields":["name","Ï_ref","converter","outer_control","inner_control","dc_source","freq_estimator","filter","base_power","n_states","states","ext","internal"],"documentation":"```\nmutable struct DynamicInverter{\n    C \u003C: Converter,\n    O \u003C: OuterControl,\n    IC \u003C: InnerControl,\n    DC \u003C: DCSource,\n    P \u003C: FrequencyEstimator,\n    F \u003C: Filter,\n} \u003C: DynamicInjection\n    name::String\n    Ï_ref::Float64\n    converter::C\n    outer_control::O\n    inner_control::IC\n    dc_source::DC\n    freq_estimator::P\n    filter::F\n    base_power::Float64\n    n_states::Int\n    states::Vector{Symbol}\n    ext::Dict{String, Any}\n    internal::InfrastructureSystemsInternal\nend\n```\n\nA dynamic inverter is composed by 6 components, namely a Converter, an Outer Control, an Inner Control, a DC Source, a Frequency Estimator and a Filter. It requires a Static Injection device that is attached to it.\n\n# Arguments\n\n  * `name::String`: Name of inverter.\n  * `Ï_ref::Float64`: Frequency reference set-point in pu.\n  * `converter \u003C: Converter`: Converter model for the PWM transformation.\n  * `outer_control \u003C: OuterControl`: Outer-control controller model.\n  * `inner_control \u003C: InnerControl`: Inner-control controller model.\n  * `dc_source \u003C: DCSource`: DC Source model.\n  * `freq_estimator \u003C: FrequencyEstimator`: Frequency Estimator (typically a PLL) model.\n  * `filter \u003C: Filter`: Filter model.\n  * `base_power::Float64`: Base power\n  * `n_states::Int`: Number of states (will depend on the components).\n  * `states::Vector{Symbol}`: Vector of states (will depend on the components).\n  * `ext::Dict{String, Any}`\n  * `internal::InfrastructureSystemsInternal`: power system internal reference, do not modify\n"},{"name":"PeriodicVariableSource","fields":["name","R_th","X_th","internal_voltage_bias","internal_voltage_frequencies","internal_voltage_coefficients","internal_angle_bias","internal_angle_frequencies","internal_angle_coefficients","base_power","states","n_states","ext","internal"],"documentation":"```\nmutable struct PeriodicVariableSource \u003C: DynamicInjection\n    name::String\n    R_th::Float64\n    X_th::Float64\n    internal_voltage_bias::Float64\n    internal_voltage_frequencies::Vector{Float64}\n    internal_voltage_coefficients::Vector{Tuple{Float64,Float64}}\n    internal_angle_bias::Float64\n    internal_angle_frequencies::Vector{Float64}\n    internal_angle_coefficients::Vector{Tuple{Float64,Float64}}\n    base_power::Float64\n    states::Vector{Symbol}\n    n_states::Int\n    ext::Dict{String, Any}\n    internal::InfrastructureSystemsInternal\nend\n```\n\nThis struct acts as an infinity bus with time varying phasor values magnitude and angle V(t) \theta(t). Time varying functions are represented using fourier series\n\n# Arguments\n\n  * `name::String`\n  * `R_th::Float64`: Source Thevenin resistance, validation range: `(0, nothing)`\n  * `X_th::Float64`: Source Thevenin reactance, validation range: `(0, nothing)`\n  * `internal_voltage_bias::Float64`: a0 term of the Fourier Series for the voltage\n  * `internal_voltage_frequencies::Vector{Float64}`: Frequencies in radians\u002Fs\n  * `internal_voltage_coefficients::Vector{Tuple{Float64,Float64}}`: Coefficients for terms n \u003E 1. First component corresponds to sin and second component to cos\n  * `internal_angle_bias::Float64`: a0 term of the Fourier Series for the angle\n  * `internal_angle_frequencies::Vector{Float64}`: Frequencies in radians\u002Fs\n  * `internal_angle_coefficients::Vector{Tuple{Float64,Float64}}`: Coefficients for terms n \u003E 1. First component corresponds to sin and second component to cos\n  * `base_power::Float64`: Base power\n  * `states::Vector{Symbol}`: State for time, voltage and angle\n  * `n_states::Int`\n  * `ext::Dict{String, Any}`\n  * `internal::InfrastructureSystemsInternal`: power system internal reference, do not modify\n"}]},{"name":"RegulationDevice","fields":["device","droop","participation_factor","reserve_limit_up","reserve_limit_dn","inertia","cost","time_series_container","internal"],"documentation":"Parametric struct to allow Injection Devices to be used in regulation services. Extends the device type and provides additional fields relevant to regulation services.\n\nDefault constructor for the Regulation Device\n"},{"name":"StaticInjection","documentation":"Abstract type of Devices that inject current\u002Fpower \n","children":[{"name":"ElectricLoad","documentation":"No documentation found.\n\n# Summary\n\n```\nabstract type ElectricLoad\n```\n\n# Subtypes\n\n```\nControllableLoad\nFixedAdmittance\nStaticLoad\n```\n\n# Supertype Hierarchy\n\n```\nElectricLoad \u003C: StaticInjection \u003C: Device \u003C: Component \u003C: InfrastructureSystems.InfrastructureSystemsComponent \u003C: InfrastructureSystems.InfrastructureSystemsType \u003C: Any\n```\n","children":[{"name":"ControllableLoad","documentation":"No documentation found.\n\n# Summary\n\n```\nabstract type ControllableLoad\n```\n\n# Subtypes\n\n```\nInterruptibleLoad\n```\n\n# Supertype Hierarchy\n\n```\nControllableLoad \u003C: ElectricLoad \u003C: StaticInjection \u003C: Device \u003C: Component \u003C: InfrastructureSystems.InfrastructureSystemsComponent \u003C: InfrastructureSystems.InfrastructureSystemsType \u003C: Any\n```\n","children":[{"name":"InterruptibleLoad","fields":["name","available","bus","model","active_power","reactive_power","max_active_power","max_reactive_power","base_power","operation_cost","services","dynamic_injector","ext","time_series_container","internal"],"documentation":"```\nmutable struct InterruptibleLoad \u003C: ControllableLoad\n    name::String\n    available::Bool\n    bus::Bus\n    model::LoadModels\n    active_power::Float64\n    reactive_power::Float64\n    max_active_power::Float64\n    max_reactive_power::Float64\n    base_power::Float64\n    operation_cost::TwoPartCost\n    services::Vector{Service}\n    dynamic_injector::Union{Nothing, DynamicInjection}\n    ext::Dict{String, Any}\n    time_series_container::InfrastructureSystems.TimeSeriesContainer\n    internal::InfrastructureSystemsInternal\nend\n```\n\n# Arguments\n\n  * `name::String`\n  * `available::Bool`\n  * `bus::Bus`\n  * `model::LoadModels`\n  * `active_power::Float64`\n  * `reactive_power::Float64`\n  * `max_active_power::Float64`\n  * `max_reactive_power::Float64`\n  * `base_power::Float64`: Base power of the unit in MVA, validation range: `(0, nothing)`, action if invalid: `warn`\n  * `operation_cost::TwoPartCost`: Operation Cost of Generation [`TwoPartCost`](@ref)\n  * `services::Vector{Service}`: Services that this device contributes to\n  * `dynamic_injector::Union{Nothing, DynamicInjection}`: corresponding dynamic injection device\n  * `ext::Dict{String, Any}`\n  * `time_series_container::InfrastructureSystems.TimeSeriesContainer`: internal time_series storage\n  * `internal::InfrastructureSystemsInternal`: power system internal reference, do not modify\n"}]},{"name":"FixedAdmittance","fields":["name","available","bus","Y","services","ext","time_series_container","internal"],"documentation":"```\nmutable struct FixedAdmittance \u003C: ElectricLoad\n    name::String\n    available::Bool\n    bus::Bus\n    Y::Complex{Float64}\n    services::Vector{Service}\n    ext::Dict{String, Any}\n    time_series_container::InfrastructureSystems.TimeSeriesContainer\n    internal::InfrastructureSystemsInternal\nend\n```\n\n# Arguments\n\n  * `name::String`\n  * `available::Bool`\n  * `bus::Bus`\n  * `Y::Complex{Float64}`: System per-unit value\n  * `services::Vector{Service}`: Services that this device contributes to\n  * `ext::Dict{String, Any}`\n  * `time_series_container::InfrastructureSystems.TimeSeriesContainer`: internal time_series storage\n  * `internal::InfrastructureSystemsInternal`: power system internal reference, do not modify\n"},{"name":"StaticLoad","documentation":"No documentation found.\n\n# Summary\n\n```\nabstract type StaticLoad\n```\n\n# Subtypes\n\n```\nPowerLoad\n```\n\n# Supertype Hierarchy\n\n```\nStaticLoad \u003C: ElectricLoad \u003C: StaticInjection \u003C: Device \u003C: Component \u003C: InfrastructureSystems.InfrastructureSystemsComponent \u003C: InfrastructureSystems.InfrastructureSystemsType \u003C: Any\n```\n","children":[{"name":"PowerLoad","fields":["name","available","bus","model","active_power","reactive_power","base_power","max_active_power","max_reactive_power","services","dynamic_injector","ext","time_series_container","internal"],"documentation":"```\nmutable struct PowerLoad \u003C: StaticLoad\n    name::String\n    available::Bool\n    bus::Bus\n    model::Union{Nothing, LoadModels}\n    active_power::Float64\n    reactive_power::Float64\n    base_power::Float64\n    max_active_power::Float64\n    max_reactive_power::Float64\n    services::Vector{Service}\n    dynamic_injector::Union{Nothing, DynamicInjection}\n    ext::Dict{String, Any}\n    time_series_container::InfrastructureSystems.TimeSeriesContainer\n    internal::InfrastructureSystemsInternal\nend\n```\n\nData structure for a static power load.\n\n# Arguments\n\n  * `name::String`\n  * `available::Bool`\n  * `bus::Bus`\n  * `model::Union{Nothing, LoadModels}`\n  * `active_power::Float64`\n  * `reactive_power::Float64`\n  * `base_power::Float64`: Base power of the unit in MVA, validation range: `(0, nothing)`, action if invalid: `warn`\n  * `max_active_power::Float64`\n  * `max_reactive_power::Float64`\n  * `services::Vector{Service}`: Services that this device contributes to\n  * `dynamic_injector::Union{Nothing, DynamicInjection}`: corresponding dynamic injection device\n  * `ext::Dict{String, Any}`\n  * `time_series_container::InfrastructureSystems.TimeSeriesContainer`: internal time_series storage\n  * `internal::InfrastructureSystemsInternal`: power system internal reference, do not modify\n"}]}]},{"name":"Generator","documentation":"Supertype for all generation technologies\n","children":[{"name":"HydroGen","documentation":"Supertype for all Hydropower generation technologies\n","children":[{"name":"HydroDispatch","fields":["name","available","bus","active_power","reactive_power","rating","prime_mover","active_power_limits","reactive_power_limits","ramp_limits","time_limits","base_power","operation_cost","services","dynamic_injector","ext","time_series_container","internal"],"documentation":"```\nmutable struct HydroDispatch \u003C: HydroGen\n    name::String\n    available::Bool\n    bus::Bus\n    active_power::Float64\n    reactive_power::Float64\n    rating::Float64\n    prime_mover::PrimeMovers\n    active_power_limits::NamedTuple{(:min, :max), Tuple{Float64, Float64}}\n    reactive_power_limits::Union{Nothing, NamedTuple{(:min, :max), Tuple{Float64, Float64}}}\n    ramp_limits::Union{Nothing, NamedTuple{(:up, :down), Tuple{Float64, Float64}}}\n    time_limits::Union{Nothing, NamedTuple{(:up, :down), Tuple{Float64, Float64}}}\n    base_power::Float64\n    operation_cost::OperationalCost\n    services::Vector{Service}\n    dynamic_injector::Union{Nothing, DynamicInjection}\n    ext::Dict{String, Any}\n    time_series_container::InfrastructureSystems.TimeSeriesContainer\n    internal::InfrastructureSystemsInternal\nend\n```\n\n# Arguments\n\n  * `name::String`\n  * `available::Bool`\n  * `bus::Bus`\n  * `active_power::Float64`\n  * `reactive_power::Float64`, validation range: `reactive_power_limits`, action if invalid: `warn`\n  * `rating::Float64`: Thermal limited MVA Power Output of the unit. \u003C= Capacity, validation range: `(0, nothing)`, action if invalid: `error`\n  * `prime_mover::PrimeMovers`: Prime mover technology according to EIA 923\n  * `active_power_limits::NamedTuple{(:min, :max), Tuple{Float64, Float64}}`, validation range: `(0, nothing)`, action if invalid: `warn`\n  * `reactive_power_limits::Union{Nothing, NamedTuple{(:min, :max), Tuple{Float64, Float64}}}`, action if invalid: `warn`\n  * `ramp_limits::Union{Nothing, NamedTuple{(:up, :down), Tuple{Float64, Float64}}}`: ramp up and ramp down limits in MW (in component base per unit) per minute, validation range: `(0, nothing)`, action if invalid: `error`\n  * `time_limits::Union{Nothing, NamedTuple{(:up, :down), Tuple{Float64, Float64}}}`: Minimum up and Minimum down time limits in hours, validation range: `(0, nothing)`, action if invalid: `error`\n  * `base_power::Float64`: Base power of the unit in MVA, validation range: `(0, nothing)`, action if invalid: `warn`\n  * `operation_cost::OperationalCost`: Operation Cost of Generation [`OperationalCost`](@ref)\n  * `services::Vector{Service}`: Services that this device contributes to\n  * `dynamic_injector::Union{Nothing, DynamicInjection}`: corresponding dynamic injection device\n  * `ext::Dict{String, Any}`\n  * `time_series_container::InfrastructureSystems.TimeSeriesContainer`: internal time_series storage\n  * `internal::InfrastructureSystemsInternal`: power system internal reference, do not modify\n"},{"name":"HydroEnergyReservoir","fields":["name","available","bus","active_power","reactive_power","rating","prime_mover","active_power_limits","reactive_power_limits","ramp_limits","time_limits","base_power","storage_capacity","inflow","initial_storage","operation_cost","storage_target","conversion_factor","time_at_status","services","dynamic_injector","ext","time_series_container","internal"],"documentation":"```\nmutable struct HydroEnergyReservoir \u003C: HydroGen\n    name::String\n    available::Bool\n    bus::Bus\n    active_power::Float64\n    reactive_power::Float64\n    rating::Float64\n    prime_mover::PrimeMovers\n    active_power_limits::NamedTuple{(:min, :max), Tuple{Float64, Float64}}\n    reactive_power_limits::Union{Nothing, Min_Max}\n    ramp_limits::Union{Nothing, NamedTuple{(:up, :down), Tuple{Float64, Float64}}}\n    time_limits::Union{Nothing, NamedTuple{(:up, :down), Tuple{Float64, Float64}}}\n    base_power::Float64\n    storage_capacity::Float64\n    inflow::Float64\n    initial_storage::Float64\n    operation_cost::OperationalCost\n    storage_target::Float64\n    conversion_factor::Float64\n    time_at_status::Float64\n    services::Vector{Service}\n    dynamic_injector::Union{Nothing, DynamicInjection}\n    ext::Dict{String, Any}\n    time_series_container::InfrastructureSystems.TimeSeriesContainer\n    internal::InfrastructureSystemsInternal\nend\n```\n\n# Arguments\n\n  * `name::String`\n  * `available::Bool`\n  * `bus::Bus`\n  * `active_power::Float64`\n  * `reactive_power::Float64`, validation range: `reactive_power_limits`, action if invalid: `warn`\n  * `rating::Float64`: Thermal limited MVA Power Output of the unit. \u003C= Capacity, validation range: `(0, nothing)`, action if invalid: `error`\n  * `prime_mover::PrimeMovers`: Prime mover technology according to EIA 923\n  * `active_power_limits::NamedTuple{(:min, :max), Tuple{Float64, Float64}}`\n  * `reactive_power_limits::Union{Nothing, Min_Max}`, action if invalid: `warn`\n  * `ramp_limits::Union{Nothing, NamedTuple{(:up, :down), Tuple{Float64, Float64}}}`: ramp up and ramp down limits in MW (in component base per unit) per minute, validation range: `(0, nothing)`, action if invalid: `error`\n  * `time_limits::Union{Nothing, NamedTuple{(:up, :down), Tuple{Float64, Float64}}}`: Minimum up and Minimum down time limits in hours, validation range: `(0, nothing)`, action if invalid: `error`\n  * `base_power::Float64`: Base power of the unit in MVA, validation range: `(0, nothing)`, action if invalid: `warn`\n  * `storage_capacity::Float64`: Maximum storage capacity in the reservoir (units can be p.u-hr or m^3)., validation range: `(0, nothing)`, action if invalid: `error`\n  * `inflow::Float64`: Baseline inflow into the reservoir (units can be p.u. or m^3\u002Fhr), validation range: `(0, nothing)`, action if invalid: `error`\n  * `initial_storage::Float64`: Initial storage capacity in the reservoir (units can be p.u-hr or m^3)., validation range: `(0, nothing)`, action if invalid: `error`\n  * `operation_cost::OperationalCost`: Operation Cost of Generation [`OperationalCost`](@ref)\n  * `storage_target::Float64`: Storage target at the end of simulation as ratio of storage capacity.\n  * `conversion_factor::Float64`: Conversion factor from flow\u002Fvolume to energy: m^3 -\u003E p.u-hr.\n  * `time_at_status::Float64`\n  * `services::Vector{Service}`: Services that this device contributes to\n  * `dynamic_injector::Union{Nothing, DynamicInjection}`: corresponding dynamic injection device\n  * `ext::Dict{String, Any}`\n  * `time_series_container::InfrastructureSystems.TimeSeriesContainer`: internal time_series storage\n  * `internal::InfrastructureSystemsInternal`: power system internal reference, do not modify\n"},{"name":"HydroPumpedStorage","fields":["name","available","bus","active_power","reactive_power","rating","base_power","prime_mover","active_power_limits","reactive_power_limits","ramp_limits","time_limits","rating_pump","active_power_limits_pump","reactive_power_limits_pump","ramp_limits_pump","time_limits_pump","storage_capacity","inflow","outflow","initial_storage","storage_target","operation_cost","pump_efficiency","conversion_factor","time_at_status","services","dynamic_injector","ext","time_series_container","internal"],"documentation":"```\nmutable struct HydroPumpedStorage \u003C: HydroGen\n    name::String\n    available::Bool\n    bus::Bus\n    active_power::Float64\n    reactive_power::Float64\n    rating::Float64\n    base_power::Float64\n    prime_mover::PrimeMovers\n    active_power_limits::NamedTuple{(:min, :max), Tuple{Float64, Float64}}\n    reactive_power_limits::Union{Nothing, NamedTuple{(:min, :max), Tuple{Float64, Float64}}}\n    ramp_limits::Union{Nothing, NamedTuple{(:up, :down), Tuple{Float64, Float64}}}\n    time_limits::Union{Nothing, NamedTuple{(:up, :down), Tuple{Float64, Float64}}}\n    rating_pump::Float64\n    active_power_limits_pump::NamedTuple{(:min, :max), Tuple{Float64, Float64}}\n    reactive_power_limits_pump::Union{Nothing, NamedTuple{(:min, :max), Tuple{Float64, Float64}}}\n    ramp_limits_pump::Union{Nothing, NamedTuple{(:up, :down), Tuple{Float64, Float64}}}\n    time_limits_pump::Union{Nothing, NamedTuple{(:up, :down), Tuple{Float64, Float64}}}\n    storage_capacity::NamedTuple{(:up, :down), Tuple{Float64, Float64}}\n    inflow::Float64\n    outflow::Float64\n    initial_storage::NamedTuple{(:up, :down), Tuple{Float64, Float64}}\n    storage_target::NamedTuple{(:up, :down), Tuple{Float64, Float64}}\n    operation_cost::OperationalCost\n    pump_efficiency::Float64\n    conversion_factor::Float64\n    time_at_status::Float64\n    services::Vector{Service}\n    dynamic_injector::Union{Nothing, DynamicInjection}\n    ext::Dict{String, Any}\n    time_series_container::InfrastructureSystems.TimeSeriesContainer\n    internal::InfrastructureSystemsInternal\nend\n```\n\n# Arguments\n\n  * `name::String`\n  * `available::Bool`\n  * `bus::Bus`\n  * `active_power::Float64`\n  * `reactive_power::Float64`\n  * `rating::Float64`: Thermal limited MVA Power Output of the unit. \u003C= Capacity, validation range: `(0, nothing)`, action if invalid: `error`\n  * `base_power::Float64`: Base power of the unit in MVA, validation range: `(0, nothing)`, action if invalid: `warn`\n  * `prime_mover::PrimeMovers`: Prime mover technology according to EIA 923\n  * `active_power_limits::NamedTuple{(:min, :max), Tuple{Float64, Float64}}`, validation range: `(0, nothing)`, action if invalid: `warn`\n  * `reactive_power_limits::Union{Nothing, NamedTuple{(:min, :max), Tuple{Float64, Float64}}}`, action if invalid: `warn`\n  * `ramp_limits::Union{Nothing, NamedTuple{(:up, :down), Tuple{Float64, Float64}}}`: ramp up and ramp down limits in MW (in component base per unit) per minute, validation range: `(0, nothing)`, action if invalid: `error`\n  * `time_limits::Union{Nothing, NamedTuple{(:up, :down), Tuple{Float64, Float64}}}`: Minimum up and Minimum down time limits in hours, validation range: `(0, nothing)`, action if invalid: `error`\n  * `rating_pump::Float64`: Thermal limited MVA Power Withdrawl of the pump. \u003C= Capacity, validation range: `(0, nothing)`, action if invalid: `error`\n  * `active_power_limits_pump::NamedTuple{(:min, :max), Tuple{Float64, Float64}}`\n  * `reactive_power_limits_pump::Union{Nothing, NamedTuple{(:min, :max), Tuple{Float64, Float64}}}`, action if invalid: `warn`\n  * `ramp_limits_pump::Union{Nothing, NamedTuple{(:up, :down), Tuple{Float64, Float64}}}`: ramp up and ramp down limits in MW (in component base per unit) per minute of pump, validation range: `(0, nothing)`, action if invalid: `error`\n  * `time_limits_pump::Union{Nothing, NamedTuple{(:up, :down), Tuple{Float64, Float64}}}`: Minimum up and Minimum down time limits of pump in hours, validation range: `(0, nothing)`, action if invalid: `error`\n  * `storage_capacity::NamedTuple{(:up, :down), Tuple{Float64, Float64}}`: Maximum storage capacity in the upper and lower reservoirs (units can be p.u-hr or m^3)., validation range: `(0, nothing)`, action if invalid: `error`\n  * `inflow::Float64`: Baseline inflow into the upper reservoir (units can be p.u. or m^3\u002Fhr), validation range: `(0, nothing)`, action if invalid: `error`\n  * `outflow::Float64`: Baseline outflow from the lower reservoir (units can be p.u. or m^3\u002Fhr), validation range: `(0, nothing)`, action if invalid: `error`\n  * `initial_storage::NamedTuple{(:up, :down), Tuple{Float64, Float64}}`: Initial storage capacity in the upper and lower reservoir (units can be p.u-hr or m^3)., validation range: `(0, nothing)`, action if invalid: `error`\n  * `storage_target::NamedTuple{(:up, :down), Tuple{Float64, Float64}}`: Storage target of upper reservoir at the end of simulation as ratio of storage capacity.\n  * `operation_cost::OperationalCost`: Operation Cost of Generation [`OperationalCost`](@ref)\n  * `pump_efficiency::Float64`: Efficiency of pump, validation range: `(0, 1)`, action if invalid: `warn`\n  * `conversion_factor::Float64`: Conversion factor from flow\u002Fvolume to energy: m^3 -\u003E p.u-hr.\n  * `time_at_status::Float64`\n  * `services::Vector{Service}`: Services that this device contributes to\n  * `dynamic_injector::Union{Nothing, DynamicInjection}`: corresponding dynamic injection device\n  * `ext::Dict{String, Any}`\n  * `time_series_container::InfrastructureSystems.TimeSeriesContainer`: internal time_series storage\n  * `internal::InfrastructureSystemsInternal`: power system internal reference, do not modify\n"}]},{"name":"RenewableGen","documentation":"Supertype for all renewable generation technologies Requires the implementation of `get_rating`and `get_power_factor` methods\n","children":[{"name":"RenewableDispatch","fields":["name","available","bus","active_power","reactive_power","rating","prime_mover","reactive_power_limits","power_factor","operation_cost","base_power","services","dynamic_injector","ext","time_series_container","internal"],"documentation":"```\nmutable struct RenewableDispatch \u003C: RenewableGen\n    name::String\n    available::Bool\n    bus::Bus\n    active_power::Float64\n    reactive_power::Float64\n    rating::Float64\n    prime_mover::PrimeMovers\n    reactive_power_limits::Union{Nothing, Min_Max}\n    power_factor::Float64\n    operation_cost::TwoPartCost\n    base_power::Float64\n    services::Vector{Service}\n    dynamic_injector::Union{Nothing, DynamicInjection}\n    ext::Dict{String, Any}\n    time_series_container::InfrastructureSystems.TimeSeriesContainer\n    internal::InfrastructureSystemsInternal\nend\n```\n\n# Arguments\n\n  * `name::String`\n  * `available::Bool`\n  * `bus::Bus`\n  * `active_power::Float64`\n  * `reactive_power::Float64`\n  * `rating::Float64`: Thermal limited MVA Power Output of the unit. \u003C= Capacity, validation range: `(0, nothing)`, action if invalid: `error`\n  * `prime_mover::PrimeMovers`: Prime mover technology according to EIA 923\n  * `reactive_power_limits::Union{Nothing, Min_Max}`\n  * `power_factor::Float64`, validation range: `(0, 1)`, action if invalid: `error`\n  * `operation_cost::TwoPartCost`: Operation Cost of Generation [`TwoPartCost`](@ref)\n  * `base_power::Float64`: Base power of the unit in MVA, validation range: `(0, nothing)`, action if invalid: `warn`\n  * `services::Vector{Service}`: Services that this device contributes to\n  * `dynamic_injector::Union{Nothing, DynamicInjection}`: corresponding dynamic injection device\n  * `ext::Dict{String, Any}`\n  * `time_series_container::InfrastructureSystems.TimeSeriesContainer`: internal time_series storage\n  * `internal::InfrastructureSystemsInternal`: power system internal reference, do not modify\n"},{"name":"RenewableFix","fields":["name","available","bus","active_power","reactive_power","rating","prime_mover","power_factor","base_power","services","dynamic_injector","ext","time_series_container","internal"],"documentation":"```\nmutable struct RenewableFix \u003C: RenewableGen\n    name::String\n    available::Bool\n    bus::Bus\n    active_power::Float64\n    reactive_power::Float64\n    rating::Float64\n    prime_mover::PrimeMovers\n    power_factor::Float64\n    base_power::Float64\n    services::Vector{Service}\n    dynamic_injector::Union{Nothing, DynamicInjection}\n    ext::Dict{String, Any}\n    time_series_container::InfrastructureSystems.TimeSeriesContainer\n    internal::InfrastructureSystemsInternal\nend\n```\n\nData Structure for fixed renewable generation technologies.\n\n# Arguments\n\n  * `name::String`\n  * `available::Bool`\n  * `bus::Bus`\n  * `active_power::Float64`\n  * `reactive_power::Float64`\n  * `rating::Float64`: Thermal limited MVA Power Output of the unit. \u003C= Capacity, validation range: `(0, nothing)`, action if invalid: `error`\n  * `prime_mover::PrimeMovers`: Prime mover technology according to EIA 923\n  * `power_factor::Float64`, validation range: `(0, 1)`, action if invalid: `error`\n  * `base_power::Float64`: Base power of the unit in MVA, validation range: `(0, nothing)`, action if invalid: `warn`\n  * `services::Vector{Service}`: Services that this device contributes to\n  * `dynamic_injector::Union{Nothing, DynamicInjection}`: corresponding dynamic injection device\n  * `ext::Dict{String, Any}`\n  * `time_series_container::InfrastructureSystems.TimeSeriesContainer`: internal time_series storage\n  * `internal::InfrastructureSystemsInternal`: power system internal reference, do not modify\n"}]},{"name":"ThermalGen","documentation":"Supertype for all Thermal generation technologies\n","children":[{"name":"ThermalMultiStart","fields":["name","available","status","bus","active_power","reactive_power","rating","prime_mover","fuel","active_power_limits","reactive_power_limits","ramp_limits","power_trajectory","time_limits","start_time_limits","start_types","operation_cost","base_power","services","time_at_status","must_run","dynamic_injector","ext","time_series_container","internal"],"documentation":"```\nmutable struct ThermalMultiStart \u003C: ThermalGen\n    name::String\n    available::Bool\n    status::Bool\n    bus::Bus\n    active_power::Float64\n    reactive_power::Float64\n    rating::Float64\n    prime_mover::PrimeMovers\n    fuel::ThermalFuels\n    active_power_limits::NamedTuple{(:min, :max), Tuple{Float64, Float64}}\n    reactive_power_limits::Union{Nothing, Min_Max}\n    ramp_limits::Union{Nothing, NamedTuple{(:up, :down), Tuple{Float64, Float64}}}\n    power_trajectory::Union{Nothing, NamedTuple{(:startup, :shutdown), Tuple{Float64, Float64}}}\n    time_limits::Union{Nothing, NamedTuple{(:up, :down), Tuple{Float64, Float64}}}\n    start_time_limits::Union{Nothing, NamedTuple{(:hot, :warm, :cold), Tuple{Float64, Float64, Float64}}}\n    start_types::Int\n    operation_cost::OperationalCost\n    base_power::Float64\n    services::Vector{Service}\n    time_at_status::Float64\n    must_run::Bool\n    dynamic_injector::Union{Nothing, DynamicInjection}\n    ext::Dict{String, Any}\n    time_series_container::InfrastructureSystems.TimeSeriesContainer\n    internal::InfrastructureSystemsInternal\nend\n```\n\nData Structure for thermal generation technologies.\n\n# Arguments\n\n  * `name::String`\n  * `available::Bool`\n  * `status::Bool`\n  * `bus::Bus`\n  * `active_power::Float64`, validation range: `active_power_limits`, action if invalid: `warn`\n  * `reactive_power::Float64`, validation range: `reactive_power_limits`, action if invalid: `warn`\n  * `rating::Float64`: Thermal limited MVA Power Output of the unit. \u003C= Capacity, validation range: `(0, nothing)`, action if invalid: `error`\n  * `prime_mover::PrimeMovers`: Prime mover technology according to EIA 923\n  * `fuel::ThermalFuels`: Prime mover fuel according to EIA 923\n  * `active_power_limits::NamedTuple{(:min, :max), Tuple{Float64, Float64}}`\n  * `reactive_power_limits::Union{Nothing, Min_Max}`\n  * `ramp_limits::Union{Nothing, NamedTuple{(:up, :down), Tuple{Float64, Float64}}}`, validation range: `(0, nothing)`, action if invalid: `error`\n  * `power_trajectory::Union{Nothing, NamedTuple{(:startup, :shutdown), Tuple{Float64, Float64}}}`: Power trajectory the unit will take during the start-up and shut-down ramp process, validation range: `(0, nothing)`, action if invalid: `error`\n  * `time_limits::Union{Nothing, NamedTuple{(:up, :down), Tuple{Float64, Float64}}}`: Minimum up and Minimum down time limits in hours, validation range: `(0, nothing)`, action if invalid: `error`\n  * `start_time_limits::Union{Nothing, NamedTuple{(:hot, :warm, :cold), Tuple{Float64, Float64, Float64}}}`:  Time limits for start-up based on turbine temperature in hours\n  * `start_types::Int`:  Number of start-up based on turbine temperature, validation range: `(1, 3)`, action if invalid: `error`\n  * `operation_cost::OperationalCost`\n  * `base_power::Float64`: Base power of the unit in MVA, validation range: `(0, nothing)`, action if invalid: `warn`\n  * `services::Vector{Service}`: Services that this device contributes to\n  * `time_at_status::Float64`\n  * `must_run::Bool`\n  * `dynamic_injector::Union{Nothing, DynamicInjection}`: corresponding dynamic injection device\n  * `ext::Dict{String, Any}`\n  * `time_series_container::InfrastructureSystems.TimeSeriesContainer`: internal time_series storage\n  * `internal::InfrastructureSystemsInternal`: power system internal reference, do not modify\n"},{"name":"ThermalStandard","fields":["name","available","status","bus","active_power","reactive_power","rating","active_power_limits","reactive_power_limits","ramp_limits","operation_cost","base_power","time_limits","prime_mover","fuel","services","time_at_status","dynamic_injector","ext","time_series_container","internal"],"documentation":"```\nmutable struct ThermalStandard \u003C: ThermalGen\n    name::String\n    available::Bool\n    status::Bool\n    bus::Bus\n    active_power::Float64\n    reactive_power::Float64\n    rating::Float64\n    active_power_limits::NamedTuple{(:min, :max), Tuple{Float64, Float64}}\n    reactive_power_limits::Union{Nothing, Min_Max}\n    ramp_limits::Union{Nothing, NamedTuple{(:up, :down), Tuple{Float64, Float64}}}\n    operation_cost::OperationalCost\n    base_power::Float64\n    time_limits::Union{Nothing, NamedTuple{(:up, :down), Tuple{Float64, Float64}}}\n    prime_mover::PrimeMovers\n    fuel::ThermalFuels\n    services::Vector{Service}\n    time_at_status::Float64\n    dynamic_injector::Union{Nothing, DynamicInjection}\n    ext::Dict{String, Any}\n    time_series_container::InfrastructureSystems.TimeSeriesContainer\n    internal::InfrastructureSystemsInternal\nend\n```\n\nData Structure for thermal generation technologies.\n\n# Arguments\n\n  * `name::String`\n  * `available::Bool`\n  * `status::Bool`\n  * `bus::Bus`\n  * `active_power::Float64`, validation range: `active_power_limits`, action if invalid: `warn`\n  * `reactive_power::Float64`, validation range: `reactive_power_limits`, action if invalid: `warn`\n  * `rating::Float64`: Thermal limited MVA Power Output of the unit. \u003C= Capacity, validation range: `(0, nothing)`, action if invalid: `error`\n  * `active_power_limits::NamedTuple{(:min, :max), Tuple{Float64, Float64}}`, validation range: `(0, nothing)`, action if invalid: `warn`\n  * `reactive_power_limits::Union{Nothing, Min_Max}`\n  * `ramp_limits::Union{Nothing, NamedTuple{(:up, :down), Tuple{Float64, Float64}}}`: ramp up and ramp down limits in MW (in component base per unit) per minute, validation range: `(0, nothing)`, action if invalid: `error`\n  * `operation_cost::OperationalCost`\n  * `base_power::Float64`: Base power of the unit in MVA, validation range: `(0, nothing)`, action if invalid: `warn`\n  * `time_limits::Union{Nothing, NamedTuple{(:up, :down), Tuple{Float64, Float64}}}`: Minimum up and Minimum down time limits in hours, validation range: `(0, nothing)`, action if invalid: `error`\n  * `prime_mover::PrimeMovers`: Prime mover technology according to EIA 923\n  * `fuel::ThermalFuels`: Prime mover fuel according to EIA 923\n  * `services::Vector{Service}`: Services that this device contributes to\n  * `time_at_status::Float64`\n  * `dynamic_injector::Union{Nothing, DynamicInjection}`: corresponding dynamic injection device\n  * `ext::Dict{String, Any}`\n  * `time_series_container::InfrastructureSystems.TimeSeriesContainer`: internal time_series storage\n  * `internal::InfrastructureSystemsInternal`: power system internal reference, do not modify\n"}]}]},{"name":"Source","fields":["name","available","bus","active_power","reactive_power","R_th","X_th","internal_voltage","internal_angle","dynamic_injector","services","ext","internal"],"documentation":"```\nmutable struct Source \u003C: StaticInjection\n    name::String\n    available::Bool\n    bus::Bus\n    active_power::Float64\n    reactive_power::Float64\n    R_th::Float64\n    X_th::Float64\n    internal_voltage::Float64\n    internal_angle::Float64\n    dynamic_injector::Union{Nothing, DynamicInjection}\n    services::Vector{Service}\n    ext::Dict{String, Any}\n    internal::InfrastructureSystemsInternal\nend\n```\n\nThis struct acts as an infinity bus.\n\n# Arguments\n\n  * `name::String`\n  * `available::Bool`\n  * `bus::Bus`\n  * `active_power::Float64`\n  * `reactive_power::Float64`\n  * `R_th::Float64`: Source Thevenin resistance, validation range: `(0, nothing)`\n  * `X_th::Float64`: Source Thevenin reactance, validation range: `(0, nothing)`\n  * `internal_voltage::Float64`: Internal Voltage, validation range: `(0, nothing)`\n  * `internal_angle::Float64`: Internal Angle\n  * `dynamic_injector::Union{Nothing, DynamicInjection}`: corresponding dynamic injection device\n  * `services::Vector{Service}`: Services that this device contributes to\n  * `ext::Dict{String, Any}`\n  * `internal::InfrastructureSystemsInternal`: power system internal reference, do not modify\n"},{"name":"StaticInjectionSubsystem","documentation":"Abstract type for a subsystem that contains multiple instances of StaticInjection\n\nSubtypes must implement:\n\n  * get_subcomponents(subsystem::StaticInjectionSubsystem)\n\nThe subcomponents in subtypes must be attached to the System as masked components.\n","children":[{"name":"HybridSystem","fields":["name","available","status","bus","active_power","reactive_power","base_power","operation_cost","thermal_unit","electric_load","storage","renewable_unit","interconnection_impedance","interconnection_rating","input_active_power_limits","output_active_power_limits","reactive_power_limits","services","dynamic_injector","ext","time_series_container","internal"],"documentation":"Representation of a Hybrid System that collects renewable generation, load, thermal generation and storage.\n\nEach generator is a data structure that is defined by the following components:\n\n  * [ThermalGen](@ref PowerSystems.ThermalGen)\n  * [Load](@ref PowerSystems.ElectricLoad)\n  * [Storage](@ref PowerSystems.Storage)\n  * [RenewableGen](@ref PowerSystems.RenewableGen)\n"}]},{"name":"Storage","documentation":"No documentation found.\n\n# Summary\n\n```\nabstract type Storage\n```\n\n# Subtypes\n\n```\nBatteryEMS\nGenericBattery\n```\n\n# Supertype Hierarchy\n\n```\nStorage \u003C: StaticInjection \u003C: Device \u003C: Component \u003C: InfrastructureSystems.InfrastructureSystemsComponent \u003C: InfrastructureSystems.InfrastructureSystemsType \u003C: Any\n```\n","children":[{"name":"BatteryEMS","fields":["name","available","bus","prime_mover","initial_energy","state_of_charge_limits","rating","active_power","input_active_power_limits","output_active_power_limits","efficiency","reactive_power","reactive_power_limits","base_power","operation_cost","storage_target","services","dynamic_injector","ext","time_series_container","internal"],"documentation":"```\nmutable struct BatteryEMS \u003C: Storage\n    name::String\n    available::Bool\n    bus::Bus\n    prime_mover::PrimeMovers\n    initial_energy::Float64\n    state_of_charge_limits::NamedTuple{(:min, :max), Tuple{Float64, Float64}}\n    rating::Float64\n    active_power::Float64\n    input_active_power_limits::NamedTuple{(:min, :max), Tuple{Float64, Float64}}\n    output_active_power_limits::NamedTuple{(:min, :max), Tuple{Float64, Float64}}\n    efficiency::NamedTuple{(:in, :out), Tuple{Float64, Float64}}\n    reactive_power::Float64\n    reactive_power_limits::Union{Nothing, Min_Max}\n    base_power::Float64\n    operation_cost::Union{Nothing, OperationalCost}\n    storage_target::Float64\n    services::Vector{Service}\n    dynamic_injector::Union{Nothing, DynamicInjection}\n    ext::Dict{String, Any}\n    time_series_container::InfrastructureSystems.TimeSeriesContainer\n    internal::InfrastructureSystemsInternal\nend\n```\n\nData structure for a battery compatible with energy management formulations.\n\n# Arguments\n\n  * `name::String`\n  * `available::Bool`\n  * `bus::Bus`\n  * `prime_mover::PrimeMovers`: Prime mover technology according to EIA 923\n  * `initial_energy::Float64`: State of Charge of the Battery p.u.-hr, validation range: `(0, nothing)`, action if invalid: `error`\n  * `state_of_charge_limits::NamedTuple{(:min, :max), Tuple{Float64, Float64}}`: Maximum and Minimum storage capacity in p.u.-hr, validation range: `(0, nothing)`, action if invalid: `error`\n  * `rating::Float64`\n  * `active_power::Float64`\n  * `input_active_power_limits::NamedTuple{(:min, :max), Tuple{Float64, Float64}}`, validation range: `(0, nothing)`, action if invalid: `error`\n  * `output_active_power_limits::NamedTuple{(:min, :max), Tuple{Float64, Float64}}`, validation range: `(0, nothing)`, action if invalid: `error`\n  * `efficiency::NamedTuple{(:in, :out), Tuple{Float64, Float64}}`, validation range: `(0, 1)`, action if invalid: `warn`\n  * `reactive_power::Float64`, validation range: `reactive_power_limits`, action if invalid: `warn`\n  * `reactive_power_limits::Union{Nothing, Min_Max}`\n  * `base_power::Float64`: Base power of the unit in MVA, validation range: `(0, nothing)`, action if invalid: `warn`\n  * `operation_cost::Union{Nothing, OperationalCost}`\n  * `storage_target::Float64`: Storage target at the end of simulation as ratio of storage capacity.\n  * `services::Vector{Service}`: Services that this device contributes to\n  * `dynamic_injector::Union{Nothing, DynamicInjection}`: corresponding dynamic injection device\n  * `ext::Dict{String, Any}`\n  * `time_series_container::InfrastructureSystems.TimeSeriesContainer`: internal time_series storage\n  * `internal::InfrastructureSystemsInternal`: power system internal reference, do not modify\n"},{"name":"GenericBattery","fields":["name","available","bus","prime_mover","initial_energy","state_of_charge_limits","rating","active_power","input_active_power_limits","output_active_power_limits","efficiency","reactive_power","reactive_power_limits","base_power","operation_cost","services","dynamic_injector","ext","time_series_container","internal"],"documentation":"```\nmutable struct GenericBattery \u003C: Storage\n    name::String\n    available::Bool\n    bus::Bus\n    prime_mover::PrimeMovers\n    initial_energy::Float64\n    state_of_charge_limits::NamedTuple{(:min, :max), Tuple{Float64, Float64}}\n    rating::Float64\n    active_power::Float64\n    input_active_power_limits::NamedTuple{(:min, :max), Tuple{Float64, Float64}}\n    output_active_power_limits::NamedTuple{(:min, :max), Tuple{Float64, Float64}}\n    efficiency::NamedTuple{(:in, :out), Tuple{Float64, Float64}}\n    reactive_power::Float64\n    reactive_power_limits::Union{Nothing, Min_Max}\n    base_power::Float64\n    operation_cost::Union{Nothing, OperationalCost}\n    services::Vector{Service}\n    dynamic_injector::Union{Nothing, DynamicInjection}\n    ext::Dict{String, Any}\n    time_series_container::InfrastructureSystems.TimeSeriesContainer\n    internal::InfrastructureSystemsInternal\nend\n```\n\nData structure for a generic battery\n\n# Arguments\n\n  * `name::String`\n  * `available::Bool`\n  * `bus::Bus`\n  * `prime_mover::PrimeMovers`: Prime mover technology according to EIA 923\n  * `initial_energy::Float64`: State of Charge of the Battery p.u.-hr, validation range: `(0, nothing)`, action if invalid: `error`\n  * `state_of_charge_limits::NamedTuple{(:min, :max), Tuple{Float64, Float64}}`: Maximum and Minimum storage capacity in p.u.-hr, validation range: `(0, nothing)`, action if invalid: `error`\n  * `rating::Float64`\n  * `active_power::Float64`\n  * `input_active_power_limits::NamedTuple{(:min, :max), Tuple{Float64, Float64}}`, validation range: `(0, nothing)`, action if invalid: `error`\n  * `output_active_power_limits::NamedTuple{(:min, :max), Tuple{Float64, Float64}}`, validation range: `(0, nothing)`, action if invalid: `error`\n  * `efficiency::NamedTuple{(:in, :out), Tuple{Float64, Float64}}`, validation range: `(0, 1)`, action if invalid: `warn`\n  * `reactive_power::Float64`, validation range: `reactive_power_limits`, action if invalid: `warn`\n  * `reactive_power_limits::Union{Nothing, Min_Max}`\n  * `base_power::Float64`: Base power of the unit in MVA, validation range: `(0, nothing)`, action if invalid: `warn`\n  * `operation_cost::Union{Nothing, OperationalCost}`\n  * `services::Vector{Service}`: Services that this device contributes to\n  * `dynamic_injector::Union{Nothing, DynamicInjection}`: corresponding dynamic injection device\n  * `ext::Dict{String, Any}`\n  * `time_series_container::InfrastructureSystems.TimeSeriesContainer`: internal time_series storage\n  * `internal::InfrastructureSystemsInternal`: power system internal reference, do not modify\n"}]}]}]},{"name":"Service","documentation":"No documentation found.\n\n# Summary\n\n```\nabstract type Service\n```\n\n# Subtypes\n\n```\nAGC\nAbstractReserve\nStaticReserveGroup{T\u003C:ReserveDirection}\nTransfer\n```\n\n# Supertype Hierarchy\n\n```\nService \u003C: Component \u003C: InfrastructureSystems.InfrastructureSystemsComponent \u003C: InfrastructureSystems.InfrastructureSystemsType \u003C: Any\n```\n","children":[{"name":"AGC","fields":["name","available","bias","K_p","K_i","K_d","delta_t","area","initial_ace","ext","internal"],"documentation":"```\nmutable struct AGC \u003C: Service\n    name::String\n    available::Bool\n    bias::Float64\n    K_p::Float64\n    K_i::Float64\n    K_d::Float64\n    delta_t::Float64\n    area::Union{Nothing, Area}\n    initial_ace::Float64\n    ext::Dict{String, Any}\n    internal::InfrastructureSystemsInternal\nend\n```\n\n# Arguments\n\n  * `name::String`\n  * `available::Bool`\n  * `bias::Float64`\n  * `K_p::Float64`: PID Proportional Constant\n  * `K_i::Float64`: PID Integral Constant\n  * `K_d::Float64`: PID Derrivative Constant\n  * `delta_t::Float64`: PID Discretization period [Seconds]\n  * `area::Union{Nothing, Area}`: the area controlled by the AGC\n  * `initial_ace::Float64`: PID Discretization period [Seconds]\n  * `ext::Dict{String, Any}`\n  * `internal::InfrastructureSystemsInternal`: power system internal reference, do not modify\n"},{"name":"AbstractReserve","documentation":"No documentation found.\n\n# Summary\n\n```\nabstract type AbstractReserve\n```\n\n# Subtypes\n\n```\nReserve{T\u003C:ReserveDirection}\nReserveNonSpinning\n```\n\n# Supertype Hierarchy\n\n```\nAbstractReserve \u003C: Service \u003C: Component \u003C: InfrastructureSystems.InfrastructureSystemsComponent \u003C: InfrastructureSystems.InfrastructureSystemsType \u003C: Any\n```\n","children":[{"name":"Reserve","documentation":"No documentation found.\n\n# Summary\n\n```\nabstract type Reserve{T\u003C:ReserveDirection}\n```\n\n# Subtypes\n\n```\nReserveDemandCurve{T\u003C:ReserveDirection}\nStaticReserve{T\u003C:ReserveDirection}\nVariableReserve{T\u003C:ReserveDirection}\n```\n\n# Supertype Hierarchy\n\n```\nReserve{T\u003C:ReserveDirection} \u003C: AbstractReserve \u003C: Service \u003C: Component \u003C: InfrastructureSystems.InfrastructureSystemsComponent \u003C: InfrastructureSystems.InfrastructureSystemsType \u003C: Any\n```\n","children":[{"name":"ReserveDemandCurve","fields":["variable","name","available","time_frame","ext","time_series_container","internal"],"documentation":"```\nmutable struct ReserveDemandCurve{T \u003C: ReserveDirection} \u003C: Reserve{T}\n    variable::Union{Nothing, IS.TimeSeriesKey}\n    name::String\n    available::Bool\n    time_frame::Float64\n    ext::Dict{String, Any}\n    time_series_container::InfrastructureSystems.TimeSeriesContainer\n    internal::InfrastructureSystemsInternal\nend\n```\n\nData Structure for a operating reserve with demand curve product for system simulations.\n\n# Arguments\n\n  * `variable::Union{Nothing, IS.TimeSeriesKey}`: Variable Cost TimeSeriesKey\n  * `name::String`\n  * `available::Bool`\n  * `time_frame::Float64`: the relative saturation time_frame, validation range: `(0, nothing)`, action if invalid: `error`\n  * `ext::Dict{String, Any}`\n  * `time_series_container::InfrastructureSystems.TimeSeriesContainer`: internal time_series storage\n  * `internal::InfrastructureSystemsInternal`: power system internal reference, do not modify\n"},{"name":"StaticReserve","fields":["name","available","time_frame","requirement","ext","internal"],"documentation":"```\nmutable struct StaticReserve{T \u003C: ReserveDirection} \u003C: Reserve{T}\n    name::String\n    available::Bool\n    time_frame::Float64\n    requirement::Float64\n    ext::Dict{String, Any}\n    internal::InfrastructureSystemsInternal\nend\n```\n\nData Structure for a proportional reserve product for system simulations.\n\n# Arguments\n\n  * `name::String`\n  * `available::Bool`\n  * `time_frame::Float64`: the relative saturation time_frame, validation range: `(0, nothing)`, action if invalid: `error`\n  * `requirement::Float64`: the static value of required reserves in system p.u., validation range: `(0, nothing)`, action if invalid: `error`\n  * `ext::Dict{String, Any}`\n  * `internal::InfrastructureSystemsInternal`: power system internal reference, do not modify\n\nAllows construction of a reserve from an iterator.\n"},{"name":"VariableReserve","fields":["name","available","time_frame","requirement","ext","time_series_container","internal"],"documentation":"```\nmutable struct VariableReserve{T \u003C: ReserveDirection} \u003C: Reserve{T}\n    name::String\n    available::Bool\n    time_frame::Float64\n    requirement::Float64\n    ext::Dict{String, Any}\n    time_series_container::InfrastructureSystems.TimeSeriesContainer\n    internal::InfrastructureSystemsInternal\nend\n```\n\nData Structure for the procurement products for system simulations.\n\n# Arguments\n\n  * `name::String`\n  * `available::Bool`\n  * `time_frame::Float64`: the relative saturation time_frame, validation range: `(0, nothing)`, action if invalid: `error`\n  * `requirement::Float64`: the required quantity of the product should be scaled by a TimeSeriesData\n  * `ext::Dict{String, Any}`\n  * `time_series_container::InfrastructureSystems.TimeSeriesContainer`: internal time_series storage\n  * `internal::InfrastructureSystemsInternal`: power system internal reference, do not modify\n"}]},{"name":"ReserveNonSpinning","documentation":"No documentation found.\n\n# Summary\n\n```\nabstract type ReserveNonSpinning\n```\n\n# Subtypes\n\n```\nStaticReserveNonSpinning\nVariableReserveNonSpinning\n```\n\n# Supertype Hierarchy\n\n```\nReserveNonSpinning \u003C: AbstractReserve \u003C: Service \u003C: Component \u003C: InfrastructureSystems.InfrastructureSystemsComponent \u003C: InfrastructureSystems.InfrastructureSystemsType \u003C: Any\n```\n","children":[{"name":"StaticReserveNonSpinning","fields":["name","available","time_frame","requirement","ext","internal"],"documentation":"```\nmutable struct StaticReserveNonSpinning \u003C: ReserveNonSpinning\n    name::String\n    available::Bool\n    time_frame::Float64\n    requirement::Float64\n    ext::Dict{String, Any}\n    internal::InfrastructureSystemsInternal\nend\n```\n\nData Structure for a non-spinning reserve product for system simulations.\n\n# Arguments\n\n  * `name::String`\n  * `available::Bool`\n  * `time_frame::Float64`: the relative saturation time_frame, validation range: `(0, nothing)`, action if invalid: `error`\n  * `requirement::Float64`: the static value of required reserves in system p.u., validation range: `(0, nothing)`, action if invalid: `error`\n  * `ext::Dict{String, Any}`\n  * `internal::InfrastructureSystemsInternal`: power system internal reference, do not modify\n"},{"name":"VariableReserveNonSpinning","fields":["name","available","time_frame","requirement","ext","time_series_container","internal"],"documentation":"```\nmutable struct VariableReserveNonSpinning \u003C: ReserveNonSpinning\n    name::String\n    available::Bool\n    time_frame::Float64\n    requirement::Float64\n    ext::Dict{String, Any}\n    time_series_container::InfrastructureSystems.TimeSeriesContainer\n    internal::InfrastructureSystemsInternal\nend\n```\n\nData Structure for the procurement products for system simulations.\n\n# Arguments\n\n  * `name::String`\n  * `available::Bool`\n  * `time_frame::Float64`: the relative saturation time_frame, validation range: `(0, nothing)`, action if invalid: `error`\n  * `requirement::Float64`: the required quantity of the product should be scaled by a TimeSeriesData\n  * `ext::Dict{String, Any}`\n  * `time_series_container::InfrastructureSystems.TimeSeriesContainer`: internal time_series storage\n  * `internal::InfrastructureSystemsInternal`: power system internal reference, do not modify\n"}]}]},{"name":"StaticReserveGroup","fields":["name","available","requirement","ext","contributing_services","internal"],"documentation":"```\nmutable struct StaticReserveGroup{T \u003C: ReserveDirection} \u003C: Service\n    name::String\n    available::Bool\n    requirement::Float64\n    ext::Dict{String, Any}\n    contributing_services::Vector{Service}\n    internal::InfrastructureSystemsInternal\nend\n```\n\nData Structure for a group reserve product for system simulations.\n\n# Arguments\n\n  * `name::String`\n  * `available::Bool`\n  * `requirement::Float64`: the static value of required reserves in system p.u., validation range: `(0, nothing)`, action if invalid: `error`\n  * `ext::Dict{String, Any}`\n  * `contributing_services::Vector{Service}`: Services that contribute for this requirement constraint\n  * `internal::InfrastructureSystemsInternal`: power system internal reference, do not modify\n"},{"name":"Transfer","fields":["name","available","requirement","ext","time_series_container","internal"],"documentation":"```\nmutable struct Transfer \u003C: Service\n    name::String\n    available::Bool\n    requirement::Float64\n    ext::Dict{String, Any}\n    time_series_container::InfrastructureSystems.TimeSeriesContainer\n    internal::InfrastructureSystemsInternal\nend\n```\n\n# Arguments\n\n  * `name::String`\n  * `available::Bool`\n  * `requirement::Float64`\n  * `ext::Dict{String, Any}`\n  * `time_series_container::InfrastructureSystems.TimeSeriesContainer`: internal time_series storage\n  * `internal::InfrastructureSystemsInternal`: power system internal reference, do not modify\n"}]},{"name":"Topology","documentation":"Abstract type to represent the structure and interconnectedness of the system\n","children":[{"name":"AggregationTopology","documentation":"Represents a geographical region of system components.\n\nAll subtypes must implement the method `get_aggregation_topology_accessor`.\n","children":[{"name":"Area","fields":["name","peak_active_power","peak_reactive_power","load_response","time_series_container","internal"],"documentation":"```\nmutable struct Area \u003C: AggregationTopology\n    name::String\n    peak_active_power::Float64\n    peak_reactive_power::Float64\n    load_response::Float64\n    time_series_container::InfrastructureSystems.TimeSeriesContainer\n    internal::InfrastructureSystemsInternal\nend\n```\n\nA collection of buses for control purposes.\n\n# Arguments\n\n  * `name::String`\n  * `peak_active_power::Float64`\n  * `peak_reactive_power::Float64`\n  * `load_response::Float64`\n  * `time_series_container::InfrastructureSystems.TimeSeriesContainer`: internal time_series storage\n  * `internal::InfrastructureSystemsInternal`: power system internal reference, do not modify\n"},{"name":"LoadZone","fields":["name","peak_active_power","peak_reactive_power","time_series_container","internal"],"documentation":"```\nmutable struct LoadZone \u003C: AggregationTopology\n    name::String\n    peak_active_power::Float64\n    peak_reactive_power::Float64\n    time_series_container::InfrastructureSystems.TimeSeriesContainer\n    internal::InfrastructureSystemsInternal\nend\n```\n\nA collection of buses for electricity price analysis.\n\n# Arguments\n\n  * `name::String`\n  * `peak_active_power::Float64`\n  * `peak_reactive_power::Float64`\n  * `time_series_container::InfrastructureSystems.TimeSeriesContainer`: internal time_series storage\n  * `internal::InfrastructureSystemsInternal`: power system internal reference, do not modify\n"}]},{"name":"Arc","fields":["from","to","internal"],"documentation":"```\nmutable struct Arc \u003C: Topology\n    from::Bus\n    to::Bus\n    internal::InfrastructureSystemsInternal\nend\n```\n\nA topological Arc.\n\n# Arguments\n\n  * `from::Bus`: The initial bus\n  * `to::Bus`: The terminal bus\n  * `internal::InfrastructureSystemsInternal`: power system internal reference, do not modify\n"},{"name":"Bus","fields":["number","name","bustype","angle","magnitude","voltage_limits","base_voltage","area","load_zone","ext","internal"],"documentation":"```\nmutable struct Bus \u003C: Topology\n    number::Int\n    name::String\n    bustype::Union{Nothing, BusTypes}\n    angle::Union{Nothing, Float64}\n    magnitude::Union{Nothing, Float64}\n    voltage_limits::Union{Nothing, Min_Max}\n    base_voltage::Union{Nothing, Float64}\n    area::Union{Nothing, Area}\n    load_zone::Union{Nothing, LoadZone}\n    ext::Dict{String, Any}\n    internal::InfrastructureSystemsInternal\nend\n```\n\nA power-system bus.\n\n# Arguments\n\n  * `number::Int`: number associated with the bus\n  * `name::String`: the name of the bus\n  * `bustype::Union{Nothing, BusTypes}`: bus type\n  * `angle::Union{Nothing, Float64}`: angle of the bus in radians, validation range: `(-1.571, 1.571)`, action if invalid: `error`\n  * `magnitude::Union{Nothing, Float64}`: voltage as a multiple of basevoltage, validation range: `voltage_limits`, action if invalid: `warn`\n  * `voltage_limits::Union{Nothing, Min_Max}`: limits on the voltage variation as multiples of basevoltage\n  * `base_voltage::Union{Nothing, Float64}`: the base voltage in kV, validation range: `(0, nothing)`, action if invalid: `error`\n  * `area::Union{Nothing, Area}`: the area containing the bus\n  * `load_zone::Union{Nothing, LoadZone}`: the load zone containing the bus\n  * `ext::Dict{String, Any}`\n  * `internal::InfrastructureSystemsInternal`: power system internal reference, do not modify\n\n```julia\nBus(number, name, bustype::String, angle, voltage, voltage_limits, base_voltage, area, load_zone; ext) -\u003E Bus\n\n```\n\nAllows construction with bus type specified as a string for legacy code.\n"}]}]}}</script></div>
	</body>
</html>
